# -*- coding: utf-8 -*-
"""TPFinalSO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1au1wuzU0Py_9ZlPl6xzYzgMHPiSDrtLh

# ¿Que hay que hacer?

Hay que crear una maquina virtual. Esto significa imitar la memoria y los registros del CPU en python.

1) Crear una lista de 65536 espacios y sus reservados. A estos espacios hay que acceder mediante la conversion de un numero binario de 16bits a entero

2) Abrir un archivo "binario" ingresado mediante su ruta por el usuario.

3) Interpretar los codigos en hexa contenidos por el archivo

4) Ejecutar las operaciones indicadas por el archivo

Cosas importantes a tener en cuenta: CADA FUNCION DEBE BUSCAR EN MEMORIA LA CANTIDAD DE "BLOQUES HEX" NECESARIOS PARA SU EJECUCIÓN, ANOTAR ESTA CANTIDAD Y DEVOLVERLA CON UN RETURN.

# **Código**

##Constantes(Memoria y registros)
"""

memoria = [str(0)] * 65536
# Registros
IP = 100
XP = 0x0000

route="C:/Users/usuario/Downloads"

# Abrir archivos
with open(route, "rb") as file:
  data = file.read()

# Cargar el programa dado en la memoria
direccion_inicial=100
direccion_final=1024
for block in data:
  block = hex(block)[2:]
  if direccion_inicial <= direccion_final:
    if block=="0":
      block="00"
    memoria[direccion_inicial]=block
  else:
    print("Error al cargar el programa en memoria, memoria llena")
  direccion_inicial+=1

"""## Mov"""

def A0(IP):
  # Los primeros 16 bits serán la direccion
  dir = memoria[IP+1]+memoria[IP+2]
  dir = int(dir,16)
  # Los siguientes 8 bits serán la constante
  constant = memoria[IP+3]
  # Muevo constant a dir
  memoria[dir] = constant
  # Retorna la posicion(dir) del bloque donde esta la siguiente funcion
  IP += 4
  return IP

def A1(IP):
  # Tomo los primeros 8 bits correspondientes a IP y los pongo en la posicion de memoria indicada
  memoria[int(memoria[IP+1],16)]=IP[0:4]
  # Los siguientes 8 bits van en la posicion siguiente a la indicada
  memoria[int(memoria[IP+1],16)+1]=IP[4:8]
  # Retorno el nuevo valor de IP que apunta a la siguiente operacion
  IP+=3
  return IP

def A2(IP):
  valor1=memoria[IP+1]
  valor2=memoria[(int(memoria[memoria[IP+1]]),16)+1]
  valor_total= valor1+valor2
  return IP

def A3(IP):
  # Tomo la posicion de memoria de origen que se compone de dos valores (Lo que apunta IP+1 ^ IP+2) y lo pongo en el destino (lo que apunta IP+3 ^ IP+4)
  memoria[int((memoria[IP+3]+memoria[IP+4]),16)] = memoria[int((memoria[IP+1]+memoria[IP+2]),16)]
  # Retorno el nuevo valor de IP que apunta a la siguiente operacion
  IP+=6
  return IP

def A4(IP):
  dir=int(memoria[IP+1] + memoria[IP+2],16) # DIR
  valor=memoria[dir]
  dir2=int(XP,16) # XP = 0x1000
  memoria[dir2]=valor
  # Retorno el nuevo valor de IP que apunta a la siguiente operacion
  IP+=3
  return IP

def A5(IP):
  # Toma la posicion de destino como la indicada por XP y muevo el valor alli apuntado a la direccion de memoria apuntada por IP+1
  memoria[memoria[IP+1],16]=memoria[int(XP,16)]
  # Retorno el nuevo valor de IP que apunta a la siguiente operacion
  IP+=3
  return IP

def A6(IP):
  valor1=XP[0]+XP[1]
  memoria[int(memoria[IP+1],16)]=valor1
  valor2=XP[2]+XP[3]
  memoria[int((memoria[IP+1]),16)+1]=valor2
  # Retorno el nuevo valor de IP que apunta a la siguiente operacion
  IP+=3
  return IP

def A7(IP):
    global XP
    # Toma el contenido indicado por IP+1 y la posición siguiente para calcular dir1
    dir1 = int(memoria[IP + 1] + memoria[IP + 2], 16)

    # Obtiene los valores en las posiciones dir1 y dir2
    valor1 = memoria[dir1]
    valor2 = memoria[dir1 + 1]
    valor1_hex=valor1
    # Convierte los valores a enteros
    valor1 = int(valor1,16)
    valor2 = int(valor2,16)

    # Concatenación de los valores en hexadecimal
    total = valor1 << 8 | valor2
    # Asigna el total hexadecimal a XP (convertido a entero para un cálculo posterior)
    XP = hex(total)

    # Retorna el nuevo valor de IP que apunta a la siguiente operación
    IP += 3
    return IP

"""  ## JMP

"""

def B0(IP):
  dir1=memoria[IP+1]+memoria[IP+2]
  dir2=memoria[IP+3]+memoria[IP+4]
  dir1=int(dir1,16)
  if 100>dir1 or dir1>1024:
    return -1
  dir2=int(dir2,16)
  if int(memoria[dir2])==0:
    IP=dir1
  else:
    IP+=5
  return IP

def B1(IP):
  dir1=memoria[IP+1]+memoria[IP+2]
  dir1=int(dir1,16)
  IP=dir1
  return IP

"""## Lógicas"""

def C0(IP):
  dir=int(memoria[IP+1]+memoria[IP+2],16)
  result=~int(memoria[dir],16) & 0xFF # Aplicamos complemento a uno y enmascaramos con 0xFF para mantenerlo en 8 bits
  memoria[dir]=hex(result)[2:]
  return IP+3

def C1(IP):
  # Tomo los elementos y los convierto de hex a int
  dir1=int(memoria[IP+1]+memoria[IP+2],16)
  dir2=int(memoria[IP+3]+memoria[IP+4],16)
  # Hago la operacion AND
  result = hex(int(memoria[dir1],16) & int(memoria[dir2],16))
  # Almaceno los primeros 8bits en una pos de memoria y los otros 8bits en la siguiente
  # Memoria[IP+3]=result[2:4]
  # Memoria[IP+4]=result[4:6]
  memoria[dir2]=result[2:]
  IP+=5
  return IP

def C2(IP):
  # Tomo los valores y los transformo a decimal
  dir1=int(memoria[IP+1]+memoria[IP+2],16)
  dir2=int(memoria[IP+3]+memoria[IP+4],16)
  # Realizo la operación lógica or
  resultado = hex(int(memoria[dir1],16) | int(memoria[dir2],16))
  # Guardo los primeros 8 bits del resultado en una posicion de memoria y los restantes en la siguiente
  memoria[dir2]=resultado[2:]
  # Retorno el nuevo valor de IP que apunta a la siguiente operacion
  IP+=5
  return IP

def C3 (IP):
    valor1=int(memoria[IP+1]+memoria[IP+2],16) # (Estos valores son direcciones de memoria)
    valor2=int(memoria[IP+3]+memoria[IP+4],16)

    # Realizo la operación XOR
    resultado = hex(int(memoria[valor1],16) ^ int(memoria[valor2],16))

    # Guardo los primeros 8 bits del resultado en una posicion de memoria y los restantes en la siguiente
    memoria[valor2]=resultado[2:]
    # Retorno el nuevo valor de IP que apunta a la siguiente operacion
    IP+=5
    return IP

"""## Aritmética"""

def D0(IP):
    val1 = memoria[IP+1]+ memoria[IP+2] # Str
    val2 = memoria[IP+3] + memoria[IP+4] # Str

    val1 = int(val1, 16)
    val2 = int(val2, 16)

    result = int(memoria[val1],16) + int(memoria[val2],16)

    result_hex = hex(result)
    memoria[val2] = result_hex[2:]
    IP+=5
    return IP

def D1(IP):
    val1 = memoria[IP+1]+ memoria[IP+2] # Str
    val2 = memoria[IP+3] + memoria[IP+4] # Str

    val3 = int(val1,16)
    val4 = int(val2,16)

    result = int(memoria[val3],16) - int(memoria[val4],16)
    result_hex = hex(result)
    memoria[val4] = result_hex[2:]
    IP += 5
    return IP

def D2(IP):
    val1 = memoria[IP+1]+ memoria[IP+2] # Str
    val2 = memoria[IP+3] + memoria[IP+4] # Str

    val1 = int(val1, 16)
    val2 = int(val2, 16)

    modulo = int(memoria[val2],16) % int(memoria[val1],16)
    modulo_hex = hex(modulo)
    memoria[val2] = modulo_hex[2:]
    IP += 5
    return IP

def D3(IP):
  global XP
  XP = int(XP, 16)
  XP += 0x1 & 0xFFFF # Me aseguro que el resultado quede en 16bits
  XP = hex(XP)
  return IP+1

def D4(IP):
  global XP
  XP = int(XP, 16)
  XP -= 0x1 & 0xFFFF
  XP = hex(XP)
  return IP+1

"""## De sistema"""

def F0(IP):
  with open("mem.dump","wb") as file:
    for element in memoria:
      int_num = int(element,16)
      bin_num= bin(int_num)[2:]
      file.write(bin_num.encode()) # Convierto a bin y escribo en file
  print("Archivo dump generado")
  return IP+1

def F1(IP):
  IP = True
  print("Ejecución finalizada")
  return IP

"""## Loop de ejecución"""

funciones = {"a0":A0,"a1":A1,"a2":A2,"a3":A3,"a4":A4,"a5":A5,"a6":A6,"a7":A7,"b0":B0,"b1":B1,"c0":C0,"c1":C1,"c2":C2,"c3":C3,"d0":D0,"d1":D1,"d2":D2,"d3":D3,"d4":D4,"f0":F0,"f1":F1}
# Bucle que ejecuta las funciones
while IP != True:
  block=memoria[IP] # Block=OpCode de la siguiente funcion
  IP=funciones[block](IP)  # Ejecuta la funcion y guarda la dir de la siguiente funcion
  # Comprueba que la funcion no haya ejecutado un error
  if IP == -1:
    print("Ha ocurrido un error fatal, reinicia el programa")
    funciones["F0"](0)
    funciones["F1"](0)

